package handlers

import (
	"context"
	"fmt"
	"log"
	"time"

	"aycom/backend/api-gateway/config"
	userProto "aycom/backend/proto/user"

	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

// UserServiceClient provides methods to interact with the User service
type UserServiceClient interface {
	// User authentication & profile operations
	Register(username, email, password, name string) (string, error)
	Login(emailOrUsername, password string) (*UserAuthResponse, error)
	GetUserProfile(userID string) (*User, error)
	UpdateUserProfile(userID string, profile *UserProfileUpdate) (*User, error)
	CheckUsernameAvailability(username string) (bool, error)
	GetUserByEmail(email string) (*User, error)

	// Social operations
	FollowUser(followerID, followedID string) error
	UnfollowUser(followerID, followedID string) error
	GetFollowers(userID string, page, limit int) ([]*User, error)
	GetFollowing(userID string, page, limit int) ([]*User, error)

	// Search operations
	SearchUsers(query string, filter string, page, limit int) ([]*User, error)
	GetUserRecommendations(userID string, limit int) ([]*User, error)
}

// User represents a user with profile information
type User struct {
	ID                string
	Username          string
	Email             string
	Name              string
	ProfilePictureURL string
	Bio               string
	IsVerified        bool
	FollowerCount     int
	FollowingCount    int
	IsFollowing       bool
	CreatedAt         time.Time
}

// UserProfileUpdate contains fields that can be updated in a user profile
type UserProfileUpdate struct {
	Name              string
	Bio               string
	ProfilePictureURL string
}

// UserAuthResponse contains authentication response data
type UserAuthResponse struct {
	UserID       string
	AccessToken  string
	RefreshToken string
	ExpiresIn    int64
	User         *User
}

// GRPCUserServiceClient is an implementation of UserServiceClient
// that communicates with the User service via gRPC
type GRPCUserServiceClient struct {
	client userProto.UserServiceClient
}

// Global instance of the user service client
var userServiceClient UserServiceClient

// InitUserServiceClient initializes the user service client
func InitUserServiceClient(cfg *config.Config) {
	// Connect to User service
	userAddr := cfg.Services.UserService

	log.Printf("Connecting to User service at %s", userAddr)

	// Connect to User service with retry mechanism
	var userConn *grpc.ClientConn
	var userErr error
	for i := 0; i < 5; i++ {
		userConn, userErr = grpc.Dial(
			userAddr,
			grpc.WithTransportCredentials(insecure.NewCredentials()),
			grpc.WithBlock(),
			grpc.WithTimeout(5*time.Second),
		)
		if userErr == nil {
			break
		}
		retryDelay := time.Duration(i+1) * time.Second
		log.Printf("Failed to connect to User service (attempt %d/5): %v. Retrying in %v...",
			i+1, userErr, retryDelay)
		time.Sleep(retryDelay)
	}
	if userErr != nil {
		log.Fatalf("CRITICAL: Failed to connect to User service after multiple attempts: %v", userErr)
	}

	// Create client with connection
	userClient := userProto.NewUserServiceClient(userConn)

	log.Printf("Successfully connected to User service at %s", userAddr)

	userServiceClient = &GRPCUserServiceClient{
		client: userClient,
	}

	log.Println("User service client initialized successfully")
}

// Register implements UserServiceClient
func (c *GRPCUserServiceClient) Register(username, email, password, name string) (string, error) {
	if c.client == nil {
		return "", fmt.Errorf("user service client not initialized")
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	// Create a User object with the registration information
	user := &userProto.User{
		Username: username,
		Email:    email,
		Password: password,
		Name:     name,
	}

	resp, err := c.client.CreateUser(ctx, &userProto.CreateUserRequest{
		User: user,
	})
	if err != nil {
		return "", err
	}

	return resp.User.Id, nil
}

// Login implements UserServiceClient
func (c *GRPCUserServiceClient) Login(emailOrUsername, password string) (*UserAuthResponse, error) {
	if c.client == nil {
		return nil, fmt.Errorf("user service client not initialized")
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	resp, err := c.client.LoginUser(ctx, &userProto.LoginUserRequest{
		Email:    emailOrUsername,
		Password: password,
	})
	if err != nil {
		return nil, err
	}

	// Since we don't have tokens in the LoginUserResponse per proto,
	// we'll need to generate them at the API gateway level
	return &UserAuthResponse{
		UserID:       resp.User.Id,
		AccessToken:  "",   // Will need to be generated by the API gateway
		RefreshToken: "",   // Will need to be generated by the API gateway
		ExpiresIn:    3600, // 1 hour default
		User:         convertProtoToUser(resp.User),
	}, nil
}

// GetUserProfile implements UserServiceClient
func (c *GRPCUserServiceClient) GetUserProfile(userID string) (*User, error) {
	if c.client == nil {
		return nil, fmt.Errorf("user service client not initialized")
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	resp, err := c.client.GetUser(ctx, &userProto.GetUserRequest{
		UserId: userID,
	})
	if err != nil {
		return nil, err
	}

	return convertProtoToUser(resp.User), nil
}

// UpdateUserProfile implements UserServiceClient
func (c *GRPCUserServiceClient) UpdateUserProfile(userID string, profile *UserProfileUpdate) (*User, error) {
	if c.client == nil {
		return nil, fmt.Errorf("user service client not initialized")
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	// Create a user object with only fields supported by the UpdateUserRequest
	// and exclude Bio which is causing the "unknown field" error
	resp, err := c.client.UpdateUser(ctx, &userProto.UpdateUserRequest{
		UserId:            userID,
		Name:              profile.Name,
		ProfilePictureUrl: profile.ProfilePictureURL,
	})
	if err != nil {
		return nil, err
	}

	return convertProtoToUser(resp.User), nil
}

// CheckUsernameAvailability implements UserServiceClient
func (c *GRPCUserServiceClient) CheckUsernameAvailability(username string) (bool, error) {
	// Since this method isn't directly available in the proto, we can implement it
	// by trying to get a user with the given username
	if c.client == nil {
		return false, fmt.Errorf("user service client not initialized")
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	// We can use GetUserByEmail as a workaround, even though it's not ideal
	resp, err := c.client.GetUserByEmail(ctx, &userProto.GetUserByEmailRequest{
		Email: username, // Using username in place of email to check availability
	})

	if err != nil {
		// If we get an error, it likely means the username doesn't exist, so it's available
		return true, nil
	}

	// If we get a response with a non-nil user, the username is taken
	return resp.User == nil, nil
}

// GetUserByEmail implements UserServiceClient
func (c *GRPCUserServiceClient) GetUserByEmail(email string) (*User, error) {
	if c.client == nil {
		return nil, fmt.Errorf("user service client not initialized")
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	resp, err := c.client.GetUserByEmail(ctx, &userProto.GetUserByEmailRequest{
		Email: email,
	})
	if err != nil {
		return nil, err
	}

	return convertProtoToUser(resp.User), nil
}

// FollowUser implements UserServiceClient
func (c *GRPCUserServiceClient) FollowUser(followerID, followedID string) error {
	// This is a mock implementation since FollowUser doesn't exist in the proto
	log.Printf("[MOCK] User %s is following user %s", followerID, followedID)
	return nil
}

// UnfollowUser implements UserServiceClient
func (c *GRPCUserServiceClient) UnfollowUser(followerID, followedID string) error {
	// This is a mock implementation since UnfollowUser doesn't exist in the proto
	log.Printf("[MOCK] User %s unfollowed user %s", followerID, followedID)
	return nil
}

// GetFollowers implements UserServiceClient
func (c *GRPCUserServiceClient) GetFollowers(userID string, page, limit int) ([]*User, error) {
	// This is a mock implementation since GetFollowers doesn't exist in the proto
	log.Printf("[MOCK] Getting followers for user %s (page %d, limit %d)", userID, page, limit)

	// Return an empty list for now
	return []*User{}, nil
}

// GetFollowing implements UserServiceClient
func (c *GRPCUserServiceClient) GetFollowing(userID string, page, limit int) ([]*User, error) {
	// This is a mock implementation since GetFollowing doesn't exist in the proto
	log.Printf("[MOCK] Getting users followed by user %s (page %d, limit %d)", userID, page, limit)

	// Return an empty list for now
	return []*User{}, nil
}

// SearchUsers implements UserServiceClient
func (c *GRPCUserServiceClient) SearchUsers(query string, filter string, page, limit int) ([]*User, error) {
	// This method isn't available in the proto, so we'll need to implement it differently
	// For now, let's just return an empty list
	return []*User{}, nil
}

// GetUserRecommendations implements UserServiceClient
func (c *GRPCUserServiceClient) GetUserRecommendations(userID string, limit int) ([]*User, error) {
	// This method isn't available in the proto, so we'll need to implement it differently
	// For now, let's just return an empty list
	return []*User{}, nil
}

// Helper function to convert proto user to User struct
func convertProtoToUser(u *userProto.User) *User {
	if u == nil {
		return nil
	}

	// Parse timestamps if they're in string format
	createdAt := time.Now()
	if u.CreatedAt != "" {
		parsedTime, err := time.Parse(time.RFC3339, u.CreatedAt)
		if err == nil {
			createdAt = parsedTime
		}
	}

	return &User{
		ID:                u.Id,
		Username:          u.Username,
		Email:             u.Email,
		Name:              u.Name,
		ProfilePictureURL: u.ProfilePictureUrl,
		Bio:               u.Bio,
		IsVerified:        false, // Not in the proto, default to false
		FollowerCount:     0,     // Not in the proto, default to 0
		FollowingCount:    0,     // Not in the proto, default to 0
		IsFollowing:       false, // Not in the proto, default to false
		CreatedAt:         createdAt,
	}
}
