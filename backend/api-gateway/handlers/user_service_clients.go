package handlers

import (
	"context"
	"fmt"
	"log"
	"time"

	"aycom/backend/api-gateway/config"
	userProto "aycom/backend/proto/user"
)

// UserServiceClient provides methods to interact with the User service
type UserServiceClient interface {
	// User authentication & profile operations
	Register(username, email, password, name string) (string, error)
	Login(emailOrUsername, password string) (*UserAuthResponse, error)
	GetUserProfile(userID string) (*User, error)
	UpdateUserProfile(userID string, profile *UserProfileUpdate) (*User, error)
	CheckUsernameAvailability(username string) (bool, error)
	GetUserByEmail(email string) (*User, error)

	// Social operations
	FollowUser(followerID, followedID string) error
	UnfollowUser(followerID, followedID string) error
	GetFollowers(userID string, page, limit int) ([]*User, error)
	GetFollowing(userID string, page, limit int) ([]*User, error)

	// Search operations
	SearchUsers(query string, filter string, page, limit int) ([]*User, int, error)
	GetUserRecommendations(userID string, limit int) ([]*User, error)
}

// User represents a user with profile information
type User struct {
	ID                string
	Username          string
	Email             string
	Name              string
	ProfilePictureURL string
	Bio               string
	IsVerified        bool
	FollowerCount     int
	FollowingCount    int
	IsFollowing       bool
	CreatedAt         time.Time
}

// UserProfileUpdate contains fields that can be updated in a user profile
type UserProfileUpdate struct {
	Name              string
	Bio               string
	ProfilePictureURL string
}

// UserAuthResponse contains authentication response data
type UserAuthResponse struct {
	UserID       string
	AccessToken  string
	RefreshToken string
	ExpiresIn    int64
	User         *User
}

// GRPCUserServiceClient is an implementation of UserServiceClient
// that communicates with the User service via gRPC
type GRPCUserServiceClient struct {
	client userProto.UserServiceClient
}

// Global instance of the user service client
var userServiceClient UserServiceClient

// InitUserServiceClient initializes the user service client
func InitUserServiceClient(cfg *config.Config) {
	if userServiceClient != nil {
		log.Println("User service client already initialized")
		return
	}

	userServiceAddr := cfg.Services.UserService
	log.Printf("Initializing User service client at %s", userServiceAddr)

	// Only attempt to initialize if we have a valid connection to the service
	if UserClient != nil {
		log.Println("Creating user service client wrapper using existing gRPC connection")
		userServiceClient = &GRPCUserServiceClient{
			client: UserClient,
		}
		log.Println("User service client initialized successfully")
	} else {
		log.Println("WARNING: Cannot initialize user service client - no connection to User service")
	}
}

// Register implements UserServiceClient
func (c *GRPCUserServiceClient) Register(username, email, password, name string) (string, error) {
	if c.client == nil {
		return "", fmt.Errorf("user service client not initialized")
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	// Create a User object with the registration information
	user := &userProto.User{
		Username: username,
		Email:    email,
		Password: password,
		Name:     name,
	}

	resp, err := c.client.CreateUser(ctx, &userProto.CreateUserRequest{
		User: user,
	})
	if err != nil {
		return "", err
	}

	return resp.User.Id, nil
}

// Login implements UserServiceClient
func (c *GRPCUserServiceClient) Login(emailOrUsername, password string) (*UserAuthResponse, error) {
	if c.client == nil {
		return nil, fmt.Errorf("user service client not initialized")
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	resp, err := c.client.LoginUser(ctx, &userProto.LoginUserRequest{
		Email:    emailOrUsername,
		Password: password,
	})
	if err != nil {
		return nil, err
	}

	// Since we don't have tokens in the LoginUserResponse per proto,
	// we'll need to generate them at the API gateway level
	return &UserAuthResponse{
		UserID:       resp.User.Id,
		AccessToken:  "",   // Will need to be generated by the API gateway
		RefreshToken: "",   // Will need to be generated by the API gateway
		ExpiresIn:    3600, // 1 hour default
		User:         convertProtoToUser(resp.User),
	}, nil
}

// GetUserProfile implements UserServiceClient
func (c *GRPCUserServiceClient) GetUserProfile(userID string) (*User, error) {
	if c.client == nil {
		return nil, fmt.Errorf("user service client not initialized")
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	resp, err := c.client.GetUser(ctx, &userProto.GetUserRequest{
		UserId: userID,
	})
	if err != nil {
		return nil, err
	}

	return convertProtoToUser(resp.User), nil
}

// UpdateUserProfile implements UserServiceClient
func (c *GRPCUserServiceClient) UpdateUserProfile(userID string, profile *UserProfileUpdate) (*User, error) {
	if c.client == nil {
		return nil, fmt.Errorf("user service client not initialized")
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	// Create a user object with only fields supported by the UpdateUserRequest
	// and exclude Bio which is causing the "unknown field" error
	resp, err := c.client.UpdateUser(ctx, &userProto.UpdateUserRequest{
		UserId:            userID,
		Name:              profile.Name,
		ProfilePictureUrl: profile.ProfilePictureURL,
	})
	if err != nil {
		return nil, err
	}

	return convertProtoToUser(resp.User), nil
}

// CheckUsernameAvailability implements UserServiceClient
func (c *GRPCUserServiceClient) CheckUsernameAvailability(username string) (bool, error) {
	// Since this method isn't directly available in the proto, we can implement it
	// by trying to get a user with the given username
	if c.client == nil {
		return false, fmt.Errorf("user service client not initialized")
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	// We can use GetUserByEmail as a workaround, even though it's not ideal
	resp, err := c.client.GetUserByEmail(ctx, &userProto.GetUserByEmailRequest{
		Email: username, // Using username in place of email to check availability
	})

	if err != nil {
		// If we get an error, it likely means the username doesn't exist, so it's available
		return true, nil
	}

	// If we get a response with a non-nil user, the username is taken
	return resp.User == nil, nil
}

// GetUserByEmail implements UserServiceClient
func (c *GRPCUserServiceClient) GetUserByEmail(email string) (*User, error) {
	if c.client == nil {
		return nil, fmt.Errorf("user service client not initialized")
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	resp, err := c.client.GetUserByEmail(ctx, &userProto.GetUserByEmailRequest{
		Email: email,
	})
	if err != nil {
		return nil, err
	}

	return convertProtoToUser(resp.User), nil
}

// SearchUsers searches for users based on query
func (c *GRPCUserServiceClient) SearchUsers(query string, filter string, page int, limit int) ([]*User, int, error) {
	if c.client == nil {
		return nil, 0, fmt.Errorf("user service client not initialized")
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	// Create the request
	req := &userProto.SearchUsersRequest{
		Query:  query,
		Filter: filter,
		Page:   int32(page),
		Limit:  int32(limit),
	}

	// Call the gRPC service
	resp, err := c.client.SearchUsers(ctx, req)
	if err != nil {
		log.Printf("Error calling SearchUsers gRPC: %v", err)
		return nil, 0, err
	}

	// Convert proto users to our User type
	users := make([]*User, 0, len(resp.GetUsers()))
	for _, protoUser := range resp.GetUsers() {
		user := convertProtoToUser(protoUser)
		if user != nil {
			users = append(users, user)
		}
	}

	// Get the total count from the response
	totalCount := int(resp.GetTotalCount())

	return users, totalCount, nil
}

// GetUserRecommendations implements UserServiceClient
func (c *GRPCUserServiceClient) GetUserRecommendations(userID string, limit int) ([]*User, error) {
	// This is a mock implementation
	// In a real implementation, we might use a specialized recommendation service
	log.Printf("[MOCK] Getting recommendations for user %s (limit %d)", userID, limit)
	return []*User{}, nil
}

// FollowUser creates a follow relationship between two users
// TODO: Replace with real gRPC implementation once proto files are regenerated
func (c *GRPCUserServiceClient) FollowUser(followerID string, followedID string) error {
	// This is a temporary mock implementation
	log.Printf("[MOCK] User %s follows user %s", followerID, followedID)

	// In a real implementation, this would call the gRPC service
	// Return success for now - we'll properly implement this after proto regeneration
	return nil
}

// UnfollowUser removes a follow relationship between two users
// TODO: Replace with real gRPC implementation once proto files are regenerated
func (c *GRPCUserServiceClient) UnfollowUser(followerID string, followedID string) error {
	// This is a temporary mock implementation
	log.Printf("[MOCK] User %s unfollows user %s", followerID, followedID)

	// In a real implementation, this would call the gRPC service
	// Return success for now - we'll properly implement this after proto regeneration
	return nil
}

// GetFollowers gets the followers of a user
// TODO: Replace with real gRPC implementation once proto files are regenerated
func (c *GRPCUserServiceClient) GetFollowers(userID string, page int, limit int) ([]*User, error) {
	// This is a temporary mock implementation
	log.Printf("[MOCK] Getting followers for user %s, page %d, limit %d", userID, page, limit)

	// Return mock data
	mockUsers := []*User{
		{
			ID:                "f47ac10b-58cc-4372-a567-0e02b2c3d479",
			Username:          "follower1",
			Name:              "Follower One",
			ProfilePictureURL: "https://example.com/avatar1.jpg",
			IsVerified:        true,
			Email:             "follower1@example.com",
		},
		{
			ID:                "f47ac10b-58cc-4372-a567-0e02b2c3d480",
			Username:          "follower2",
			Name:              "Follower Two",
			ProfilePictureURL: "https://example.com/avatar2.jpg",
			IsVerified:        false,
			Email:             "follower2@example.com",
		},
	}

	return mockUsers, nil
}

// GetFollowing gets the users followed by a user
// TODO: Replace with real gRPC implementation once proto files are regenerated
func (c *GRPCUserServiceClient) GetFollowing(userID string, page int, limit int) ([]*User, error) {
	// This is a temporary mock implementation
	log.Printf("[MOCK] Getting following for user %s, page %d, limit %d", userID, page, limit)

	// Return mock data
	mockUsers := []*User{
		{
			ID:                "f47ac10b-58cc-4372-a567-0e02b2c3d481",
			Username:          "following1",
			Name:              "Following One",
			ProfilePictureURL: "https://example.com/avatar3.jpg",
			IsVerified:        true,
			Email:             "following1@example.com",
		},
		{
			ID:                "f47ac10b-58cc-4372-a567-0e02b2c3d482",
			Username:          "following2",
			Name:              "Following Two",
			ProfilePictureURL: "https://example.com/avatar4.jpg",
			IsVerified:        false,
			Email:             "following2@example.com",
		},
	}

	return mockUsers, nil
}

// Helper to convert proto User to internal User type
func convertProtoToUser(u *userProto.User) *User {
	if u == nil {
		return nil
	}

	createdAt := time.Time{}
	if u.CreatedAt != "" {
		parsed, err := time.Parse(time.RFC3339, u.CreatedAt)
		if err == nil {
			createdAt = parsed
		}
	}

	// Create user with the fields we know exist in the proto
	result := &User{
		ID:                u.Id,
		Username:          u.Username,
		Email:             u.Email,
		Name:              u.Name,
		ProfilePictureURL: u.ProfilePictureUrl,
		// Fields that might not be in the proto are given default values
		Bio:            "",
		FollowerCount:  0,
		FollowingCount: 0,
		IsFollowing:    false,
		CreatedAt:      createdAt,
		IsVerified:     false, // Default value
	}

	return result
}
